# 基本概念  
配置（Configuration）：对机器人上面所有的点的位置的描述  
自由度（degree of freedom，DOF）：用最少的坐标的数量去表示机器人存在的配置  
配置空间（Configuration Space）：有n个维度的空间中，包含了所有的机器人可能存在的位姿   
# 图搜索  
给定一个容器(openlist)，第一个放入的就是设定的起始节点。进入循环，在容器里，根据实现给定的指标或目的，弹出一个节点（访问一个节点）。扩展：发现其所有存在的邻居节点，把扩展的新的节点放入容器中，直到完成目标或其他指标后终止循环。  
## 深度优先算法  
遵从后进先出原则，是一个堆栈，先弹出已有节点中最深层级的节点，也就是优先把一条路径走到底。  
## 广度优先算法
遵从先进先出原则，是一个队列。先弹已有节点中最浅层级节点，容器优先遍历完最浅的一层的节点后才回去访问更深层的节点。  
BFS虽然搜索的可能会比较慢，但是搜索到目标终点后回溯一定是可以得到较好的路径的，优先使用。  
## 贪心算法
贪心算法的弹出策略是人为去规定的，heuristic是一个对于目前与终点之间距离的猜测（忽视障碍物的欧氏距离或x、y轴分别距离和的曼哈顿距离等），因此可以启发路径搜索通往较优的方向。  
## Dijkstra算法  
priority queue即优先级队列，这个队列中的排序方式是通过g（n）也就是cost的大小来进行排序的。  
弹出原则是：每次弹出的节点具备最小的cost g（n），g（n）表示的是，从起点出发到当前节点积累的cost。 
会更新n节点的所有未被扩展的邻居节点m，如果从n到m这个走向的g（m）比原来的cost小的话，就会做一个cost的更新。  
最优性的保证：每一个被扩展过的节点的g（n）都能保证是起始节点到当前n节点的最小代价的路径。  
## A* 算法  
A算法的弹出节点的判断方式转换为最小的f（n）=g（n）+h（n），即累计cost和与终点猜测值的和。  
为了保证A* 算法的最优性，需要保证每个节点估计出来的h（n）是小于其真实到达最终点的路径长度h的。  
weighted A* 所采用的方式，排序依赖的函数变为f = g + εh, ε > 1，ε越大，整个算法越向贪心算法靠拢，ε越小整个算法越向Dijkstra算法靠拢。  
### tie breaker（破坏对称性）    
引入一个系数p（一般非常小），一步最小的cost与期待最长的cost的比值，这样会让本来有着相同f的两个节点产生细微差别，从而让模型更具备倾向性。  
对同样的f的节点，再根据其h进行排序  
对每一个节点加上一个随机的数值（事先确定好每一个坐标不一样，根据坐标构建哈希表）  
添加选节点的倾向性（可以人为设定）  
## Jump Point Search-跳点搜索法  
JPS与A*算法主要区别在后继节点拓展策略上（基于跳点）  
1.强迫邻居：节点 x 的8个邻居中有障碍，且 x 的父节点 p 经过x 到达 n 的距离代价比不经过 x 到达的 n 的任意路径的距离代价小，则称 n 是 x 的强迫邻居。  
2.跳点：如果点 x是起点或目标点，则 x 是跳点。  
        如果x 有强迫邻居则 x 是跳点。  
        如果 parent(x)到 x 是对角线移动，并且 x 经过水平或垂直方向移动可以到达跳点，则 x 是跳点。  
3.原则：
劣性节点：如果从parent(x)到x是直线/对角线移动，n是x的邻居，若有从parent(x)不经过x到n的路径长度小于或等于从parent(x)经过x到n的路径，则走到x后下一个点不会走到n。  
首先在直线方向搜索跳点，再在对角线方向搜索跳点。    
只有跳点才会加入openlist，因为跳点会改变行走方向，而非跳点不会改变行走方向，最后寻找出来的路径点也只会是跳点集合的子集。  
