# 状态栅格搜索算法：State Lattice Search  
有两种思路去实现这样的建图   
状态s的导数是一个由状态和输入为变量去描述的函数。一般会给一个初始状态  
离散化控制空间：给系统不同的u，并保持一定的时间，看系统在不同的激励下会变成什么样子。前向仿真，易于实现，，没有目的性的扩展，容易造成较低的效率。  
离散化状态空间：给定状态，从两个状态之间解析运动的边（解出u和T），看什么样的u,u可以是加速度，加速度的导数jerk和T能让机器人从一个状态到另外一个状态。反向的计算，比较难实现，但是自然地具备heuristic的效果。 

状态空间采样的方法要好一些，因为不会出现那些失败的路径。而且如果控制空间的输入变化的范围控制不好的话，可能会导致一系列的路径都容易是失败的，因为他们比较接近。  
# Boundary Value Problem （BVP）  
给定初始和终点两个状态，我们想要去找到中间的最优 $s^* $ 和 $u^* $                 
## 概念  
1.目标函数：![1](https://latex.codecogs.com/svg.image?J=k=13&space;Jk,Jk=T1&space;0T&space;jk(t)2dt) 
这个目标函数描述的是：首先，将三维的运动的任务分解为单独一个维度再一起考虑，然后每一个维度考虑的是一段时间T内jerk的平均变化程度，平方是因为jerk自身表示加速度的导数，有正有负。    
2.状态：![2](https://latex.codecogs.com/svg.image?sk=(pk,vk,ak)) 状态某一个维度上的位置、速度以及加速度  
3.输入：![3](https://latex.codecogs.com/svg.image?&space;uk=jk&space;) 
4.系统方程：![4](https://latex.codecogs.com/svg.image?s=fs(s,u)=(v,a,j))  
## 过程  
![1.png](https://s2.loli.net/2024/11/07/1jDy5eK9zARa6TG.png)  
![2.png](https://s2.loli.net/2024/11/07/r1q6JeCRH9mbXDW.png)  
![3.png](https://s2.loli.net/2024/11/07/4JnpamEUu9q1czK.png)  
![4.png](https://s2.loli.net/2024/11/07/TM41KoscWRNBLny.png)  
注：把协态的那一组解，带入汉密尔顿函数，然后对jerk做偏导，得到极值点对应的j的值  
# Hybrid A*   
A* 算法的扩展节点是栅格的交点，因此不能解决在连续空间内车辆朝向和位置的问题。而Hybrid A*算法通过使用车辆运动学生成的轨迹替代A*算法中的节点，从而解决路径不满足车辆运动学的问题。如图所示，A* 算法扩展节点时为八个格子，Hybrid A* 算法扩展节点时有六个运动基原，向前扩展三个运动模式，向后扩展三个运动模式。  

hybrid A* 算法将启发函数分成两种：无障碍物的非完整性约束启发代价和有障碍物的完整性启发式代价。  
无障碍物的非完整约束启发代价  
这第一个启发式代价主要是忽略了在路径规划中障碍物对规划器的影响。这项启发函数必须获得车辆的最小转弯半径作为输入。并且，改启发函数主要是通过离散周围的栅格地图，获得不同方向坐标点并使用最优曲线计算路径长度。比如，在需要计算起始点到目标点的最优曲线的路径长度时。首先，是在起始点使用Dubins曲线或者Reeds-Shepp曲线连接目标点，得到最优曲线的路径长度。然后，计算最优曲线的距离，并作为启发函数的代价值。  
第二项代价函数主要是考虑环境中障碍物信息，但忽略了车辆的最小转弯半径对其的影响。通过在每个节点上使用Djikstra算法获得该节点到达目标点的最近距离作为其代价函数的代价值。  
选中其中较大的代价作为Hybrid A*的代价值。  

# Kinodynamic RRT*  
传统的RRT * 算法在采样时在欧几里德空间中仅对位置进行采样，而Kinodynamic RRT * 算法是在全状态空间中采样。比如，针对位置、速度进行采样。  
与传统的RRT * 算法不同，Kinodynamic RRT*算法在寻找最"邻近"节点时，不能仅考虑位置上最接近，而是需要考虑动力学约束，所以这里的最“邻近”节点，可以理解成到新节点连接代价值最小的节点。上述过程中需要求解两个节点间的轨迹，即两点边界值问题BVP、或最优两点边界值问题OBVP
