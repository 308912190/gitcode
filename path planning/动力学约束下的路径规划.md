# 状态栅格搜索算法：State Lattice Search  
有两种思路去实现这样的建图   
状态s的导数是一个由状态和输入为变量去描述的函数。一般会给一个初始状态  
离散化控制空间：给系统不同的u，并保持一定的时间，看系统在不同的激励下会变成什么样子。前向仿真，易于实现，，没有目的性的扩展，容易造成较低的效率。  
离散化状态空间：给定状态，从两个状态之间解析运动的边（解出u和T），看什么样的u,u可以是加速度，加速度的导数jerk和T能让机器人从一个状态到另外一个状态。反向的计算，比较难实现，但是自然地具备heuristic的效果。 

状态空间采样的方法要好一些，因为不会出现那些失败的路径。而且如果控制空间的输入变化的范围控制不好的话，可能会导致一系列的路径都容易是失败的，因为他们比较接近。  
# Boundary Value Problem （BVP）  
给定初始和终点两个状态，我们想要去找到中间的最优 $s^* $ 和 $u^* $                 
## 概念  
1.目标函数：![1](https://latex.codecogs.com/svg.image?J=k=13&space;Jk,Jk=T1&space;0T&space;jk(t)2dt) 
这个目标函数描述的是：首先，将三维的运动的任务分解为单独一个维度再一起考虑，然后每一个维度考虑的是一段时间T内jerk的平均变化程度，平方是因为jerk自身表示加速度的导数，有正有负。    
2.状态：![2](https://latex.codecogs.com/svg.image?sk=(pk,vk,ak)) 状态某一个维度上的位置、速度以及加速度  
3.输入：![3](https://latex.codecogs.com/svg.image?&space;uk=jk&space;) 
4.系统方程：![4](https://latex.codecogs.com/svg.image?s=fs(s,u)=(v,a,j))  
## 过程  
![1.png](https://s2.loli.net/2024/11/07/1jDy5eK9zARa6TG.png)  
![2.png](https://s2.loli.net/2024/11/07/r1q6JeCRH9mbXDW.png)  
![3.png](https://s2.loli.net/2024/11/07/4JnpamEUu9q1czK.png)  
![4.png](https://s2.loli.net/2024/11/07/TM41KoscWRNBLny.png)  
注：把协态的那一组解，带入汉密尔顿函数，然后对jerk做偏导，得到极值点对应的j的值  
# Hybrid A* 
